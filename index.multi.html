<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - multiple views with OrbitControls</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

  <div id="container"></div>
  <div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - multiple views with OrbitControls
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "./three.js-r175/build/three.module.js",
        "three/addons/": "./three.js-r175/examples/jsm/"
      }
    }
  </script>

  <script type="module">

    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let stats;
    let scene, renderer;
    let windowWidth = window.innerWidth, windowHeight = window.innerHeight;

    const views = [
      {
        left: 0,
        bottom: 0,
        width: 1.0,
        height: 1.0,
        background: new THREE.Color(0.5,0.5,0.5),//new THREE.Color(0.5, 0.5, 0.7),
        eye: [0, 300, 1800],
        up: [0, 1, 0],
        fov: 30
      },
      {
        left: 0.75,
        bottom: 0.75,
        width: 0.25,
        height: 0.25,
        background: new THREE.Color(0,0,0),//new THREE.Color(0.7, 0.5, 0.5),
        eye: [0, 1800, 0],
        up: [0, 0, 1],
        fov: 45
      },
      {
        left: 0.5,
        bottom: 0.75,
        width: 0.25,
        height: 0.25,
        background: new THREE.Color(0,0,0),//new THREE.Color(0.5, 0.7, 0.7),
        eye: [1400, 800, 1400],
        up: [0, 1, 0],
        fov: 60
      }
    ];

    init();

    function init() {
      const container = document.getElementById('container');

      scene = new THREE.Scene();

      const light = new THREE.DirectionalLight(0xffffff, 3);
      light.position.set(0, 0, 1);
      scene.add(light);

      // Shadow texture
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
      gradient.addColorStop(0.1, 'rgba(0,0,0,0.15)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, 128, 128);
      const shadowTexture = new THREE.CanvasTexture(canvas);
      const shadowMaterial = new THREE.MeshBasicMaterial({ map: shadowTexture, transparent: true });
      const shadowGeo = new THREE.PlaneGeometry(300, 300);

      for (let x of [-400, 0, 400]) {
        const shadowMesh = new THREE.Mesh(shadowGeo, shadowMaterial);
        shadowMesh.position.set(x, -250, 0);
        shadowMesh.rotation.x = -Math.PI / 2;
        scene.add(shadowMesh);
      }

      // Meshes
      const radius = 200;
      const geometry1 = new THREE.IcosahedronGeometry(radius, 1);
      const count = geometry1.attributes.position.count;
      geometry1.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
      const geometry2 = geometry1.clone();
      const geometry3 = geometry1.clone();

      const color = new THREE.Color();
      const positions1 = geometry1.attributes.position;
      const colors1 = geometry1.attributes.color;
      const positions2 = geometry2.attributes.position;
      const colors2 = geometry2.attributes.color;
      const positions3 = geometry3.attributes.position;
      const colors3 = geometry3.attributes.color;

      for (let i = 0; i < count; i++) {
        color.setHSL((positions1.getY(i) / radius + 1) / 2, 1.0, 0.5);
        colors1.setXYZ(i, color.r, color.g, color.b);
        color.setHSL(0, (positions2.getY(i) / radius + 1) / 2, 0.5);
        colors2.setXYZ(i, color.r, color.g, color.b);
        color.setRGB(1, 0.8 - (positions3.getY(i) / radius + 1) / 2, 0);
        colors3.setXYZ(i, color.r, color.g, color.b);
      }

      const material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        flatShading: true,
        vertexColors: true,
        shininess: 0
      });

      const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true });

      const mesh1 = new THREE.Mesh(geometry1, material);
      mesh1.add(new THREE.Mesh(geometry1, wireframeMaterial));
      mesh1.position.x = -400;
      mesh1.rotation.x = -1.87;
      scene.add(mesh1);

      const mesh2 = new THREE.Mesh(geometry2, material);
      mesh2.add(new THREE.Mesh(geometry2, wireframeMaterial));
      mesh2.position.x = 400;
      scene.add(mesh2);

      const mesh3 = new THREE.Mesh(geometry3, material);
      mesh3.add(new THREE.Mesh(geometry3, wireframeMaterial));
      scene.add(mesh3);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setAnimationLoop(animate);
      container.appendChild(renderer.domElement);

      stats = new Stats();
      container.appendChild(stats.dom);

      for (let view of views) {
        const camera = new THREE.PerspectiveCamera(view.fov, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.fromArray(view.eye);
        camera.up.fromArray(view.up);
        view.camera = camera;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();
        view.controls = controls;
      }
    }

    function updateSize() {
      if (windowWidth !== window.innerWidth || windowHeight !== window.innerHeight) {
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight;
        renderer.setSize(windowWidth, windowHeight);
      }
    }

    function animate() {
      render();
      stats.update();
    }

    function render() {
      updateSize();

      for (let view of views) {
        const { camera, controls, left, bottom, width, height, background } = view;

        controls.update();

        const vpLeft = Math.floor(windowWidth * left);
        const vpBottom = Math.floor(windowHeight * bottom);
        const vpWidth = Math.floor(windowWidth * width);
        const vpHeight = Math.floor(windowHeight * height);

        renderer.setViewport(vpLeft, vpBottom, vpWidth, vpHeight);
        renderer.setScissor(vpLeft, vpBottom, vpWidth, vpHeight);
        renderer.setScissorTest(true);
        renderer.setClearColor(background);

        camera.aspect = vpWidth / vpHeight;
        camera.updateProjectionMatrix();

        renderer.render(scene, camera);
      }
    }

  </script>

</body>
</html>
